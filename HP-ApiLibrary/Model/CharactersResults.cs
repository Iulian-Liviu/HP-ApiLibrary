// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using HPApiLibrary.Model;
//
//    var charactersResults = CharactersResults.FromJson(jsonString);

namespace HPApiLibrary.Model
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class CharactersResults
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("alternate_names")]
        public List<string> AlternateNames { get; set; }

        [JsonProperty("species")]
        public Species Species { get; set; }

        [JsonProperty("gender")]
        public Gender Gender { get; set; }

        [JsonProperty("house")]
        public House House { get; set; }

        [JsonProperty("dateOfBirth")]
        public DateOfBirth DateOfBirth { get; set; }

        [JsonProperty("yearOfBirth")]
        public YearOfBirth YearOfBirth { get; set; }

        [JsonProperty("wizard")]
        public bool Wizard { get; set; }

        [JsonProperty("ancestry")]
        public Ancestry Ancestry { get; set; }

        [JsonProperty("eyeColour")]
        public EyeColour EyeColour { get; set; }

        [JsonProperty("hairColour")]
        public HairColour HairColour { get; set; }

        [JsonProperty("wand")]
        public Wand Wand { get; set; }

        [JsonProperty("patronus")]
        public Patronus Patronus { get; set; }

        [JsonProperty("hogwartsStudent")]
        public bool HogwartsStudent { get; set; }

        [JsonProperty("hogwartsStaff")]
        public bool HogwartsStaff { get; set; }

        [JsonProperty("actor")]
        public string Actor { get; set; }

        [JsonProperty("alternate_actors")]
        public List<string> AlternateActors { get; set; }

        [JsonProperty("alive")]
        public bool Alive { get; set; }

        [JsonProperty("image")]
        public string Image { get; set; }
    }

    public partial class Wand
    {
        [JsonProperty("wood")]
        public Wood Wood { get; set; }

        [JsonProperty("core")]
        public Core Core { get; set; }

        [JsonProperty("length")]
        public Length Length { get; set; }
    }

    public enum Ancestry { Empty, HalfBlood, HalfVeela, Muggle, Muggleborn, PureBlood, QuarterVeela, Squib };

    public enum DateOfBirth { Empty, The01031980, The03111959, The04101925, The05061980, The06021950, The06121928, The09011960, The10031960, The11081981, The13021981, The19091979, The30071980, The31071980, The31121926 };

    public enum EyeColour { Amber, Black, Blue, Brown, Dark, Empty, Green, Grey, Hazel, Orange, PaleSilvery, Red, White, Yellow, Yellowish };

    public enum Gender { Female, Male };

    public enum HairColour { Bald, Black, Blond, Blonde, Brown, Dark, Dull, Empty, Ginger, Grey, Red, Sandy, Silver, Tawny, White };

    public enum House { Empty, Gryffindor, Hufflepuff, Ravenclaw, Slytherin };

    public enum Patronus { Boar, Doe, Empty, Goat, Hare, Horse, JackRussellTerrier, Lynx, Otter, PersianCat, Stag, Swan, TabbyCat, Weasel, Wolf };

    public enum Species { Acromantula, Cat, Centaur, Dragon, Ghost, Giant, Goblin, HalfGiant, HalfHuman, Hippogriff, HouseElf, Human, Owl, Poltergeist, ThreeHeadedDog, Vampire, Werewolf };

    public enum Core { DragonHeartstring, Empty, PhoenixFeather, UnicornHair, UnicornTailHair };

    public enum Wood { Ash, Birch, Cedar, Cherry, Chestnut, Cypress, Elm, Empty, Hawthorn, Holly, Hornbeam, Larch, Mahogany, Oak, Vine, Walnut, Willow, Yew };

    public partial struct Length
    {
        public double? Double;
        public string String;

        public static implicit operator Length(double Double) => new Length { Double = Double };
        public static implicit operator Length(string String) => new Length { String = String };
    }

    public partial struct YearOfBirth
    {
        public long? Integer;
        public string String;

        public static implicit operator YearOfBirth(long Integer) => new YearOfBirth { Integer = Integer };
        public static implicit operator YearOfBirth(string String) => new YearOfBirth { String = String };
    }

    public partial class CharactersResults
    {
        public static List<CharactersResults> FromJson(string json) => JsonConvert.DeserializeObject<List<CharactersResults>>(json, HPApiLibrary.Model.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this List<CharactersResults> self) => JsonConvert.SerializeObject(self, HPApiLibrary.Model.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                AncestryConverter.Singleton,
                DateOfBirthConverter.Singleton,
                EyeColourConverter.Singleton,
                GenderConverter.Singleton,
                HairColourConverter.Singleton,
                HouseConverter.Singleton,
                PatronusConverter.Singleton,
                SpeciesConverter.Singleton,
                CoreConverter.Singleton,
                LengthConverter.Singleton,
                WoodConverter.Singleton,
                YearOfBirthConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class AncestryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Ancestry) || t == typeof(Ancestry?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return Ancestry.Empty;
                case "half-blood":
                    return Ancestry.HalfBlood;
                case "half-veela":
                    return Ancestry.HalfVeela;
                case "muggle":
                    return Ancestry.Muggle;
                case "muggleborn":
                    return Ancestry.Muggleborn;
                case "pure-blood":
                    return Ancestry.PureBlood;
                case "quarter-veela":
                    return Ancestry.QuarterVeela;
                case "squib":
                    return Ancestry.Squib;
            }
            throw new Exception("Cannot unmarshal type Ancestry");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Ancestry)untypedValue;
            switch (value)
            {
                case Ancestry.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case Ancestry.HalfBlood:
                    serializer.Serialize(writer, "half-blood");
                    return;
                case Ancestry.HalfVeela:
                    serializer.Serialize(writer, "half-veela");
                    return;
                case Ancestry.Muggle:
                    serializer.Serialize(writer, "muggle");
                    return;
                case Ancestry.Muggleborn:
                    serializer.Serialize(writer, "muggleborn");
                    return;
                case Ancestry.PureBlood:
                    serializer.Serialize(writer, "pure-blood");
                    return;
                case Ancestry.QuarterVeela:
                    serializer.Serialize(writer, "quarter-veela");
                    return;
                case Ancestry.Squib:
                    serializer.Serialize(writer, "squib");
                    return;
            }
            throw new Exception("Cannot marshal type Ancestry");
        }

        public static readonly AncestryConverter Singleton = new AncestryConverter();
    }

    internal class DateOfBirthConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DateOfBirth) || t == typeof(DateOfBirth?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return DateOfBirth.Empty;
                case "01-03-1980":
                    return DateOfBirth.The01031980;
                case "03-11-1959":
                    return DateOfBirth.The03111959;
                case "04-10-1925":
                    return DateOfBirth.The04101925;
                case "05-06-1980":
                    return DateOfBirth.The05061980;
                case "06-02-1950":
                    return DateOfBirth.The06021950;
                case "06-12-1928":
                    return DateOfBirth.The06121928;
                case "09-01-1960":
                    return DateOfBirth.The09011960;
                case "10-03-1960":
                    return DateOfBirth.The10031960;
                case "11-08-1981":
                    return DateOfBirth.The11081981;
                case "13-02-1981":
                    return DateOfBirth.The13021981;
                case "19-09-1979":
                    return DateOfBirth.The19091979;
                case "30-07-1980":
                    return DateOfBirth.The30071980;
                case "31-07-1980":
                    return DateOfBirth.The31071980;
                case "31-12-1926":
                    return DateOfBirth.The31121926;
            }
            throw new Exception("Cannot unmarshal type DateOfBirth");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DateOfBirth)untypedValue;
            switch (value)
            {
                case DateOfBirth.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case DateOfBirth.The01031980:
                    serializer.Serialize(writer, "01-03-1980");
                    return;
                case DateOfBirth.The03111959:
                    serializer.Serialize(writer, "03-11-1959");
                    return;
                case DateOfBirth.The04101925:
                    serializer.Serialize(writer, "04-10-1925");
                    return;
                case DateOfBirth.The05061980:
                    serializer.Serialize(writer, "05-06-1980");
                    return;
                case DateOfBirth.The06021950:
                    serializer.Serialize(writer, "06-02-1950");
                    return;
                case DateOfBirth.The06121928:
                    serializer.Serialize(writer, "06-12-1928");
                    return;
                case DateOfBirth.The09011960:
                    serializer.Serialize(writer, "09-01-1960");
                    return;
                case DateOfBirth.The10031960:
                    serializer.Serialize(writer, "10-03-1960");
                    return;
                case DateOfBirth.The11081981:
                    serializer.Serialize(writer, "11-08-1981");
                    return;
                case DateOfBirth.The13021981:
                    serializer.Serialize(writer, "13-02-1981");
                    return;
                case DateOfBirth.The19091979:
                    serializer.Serialize(writer, "19-09-1979");
                    return;
                case DateOfBirth.The30071980:
                    serializer.Serialize(writer, "30-07-1980");
                    return;
                case DateOfBirth.The31071980:
                    serializer.Serialize(writer, "31-07-1980");
                    return;
                case DateOfBirth.The31121926:
                    serializer.Serialize(writer, "31-12-1926");
                    return;
            }
            throw new Exception("Cannot marshal type DateOfBirth");
        }

        public static readonly DateOfBirthConverter Singleton = new DateOfBirthConverter();
    }

    internal class EyeColourConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EyeColour) || t == typeof(EyeColour?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return EyeColour.Empty;
                case "amber":
                    return EyeColour.Amber;
                case "black":
                    return EyeColour.Black;
                case "blue":
                    return EyeColour.Blue;
                case "brown":
                    return EyeColour.Brown;
                case "dark":
                    return EyeColour.Dark;
                case "green":
                    return EyeColour.Green;
                case "grey":
                    return EyeColour.Grey;
                case "hazel":
                    return EyeColour.Hazel;
                case "orange":
                    return EyeColour.Orange;
                case "pale, silvery":
                    return EyeColour.PaleSilvery;
                case "red":
                    return EyeColour.Red;
                case "white":
                    return EyeColour.White;
                case "yellow":
                    return EyeColour.Yellow;
                case "yellowish":
                    return EyeColour.Yellowish;
            }
            throw new Exception("Cannot unmarshal type EyeColour");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (EyeColour)untypedValue;
            switch (value)
            {
                case EyeColour.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case EyeColour.Amber:
                    serializer.Serialize(writer, "amber");
                    return;
                case EyeColour.Black:
                    serializer.Serialize(writer, "black");
                    return;
                case EyeColour.Blue:
                    serializer.Serialize(writer, "blue");
                    return;
                case EyeColour.Brown:
                    serializer.Serialize(writer, "brown");
                    return;
                case EyeColour.Dark:
                    serializer.Serialize(writer, "dark");
                    return;
                case EyeColour.Green:
                    serializer.Serialize(writer, "green");
                    return;
                case EyeColour.Grey:
                    serializer.Serialize(writer, "grey");
                    return;
                case EyeColour.Hazel:
                    serializer.Serialize(writer, "hazel");
                    return;
                case EyeColour.Orange:
                    serializer.Serialize(writer, "orange");
                    return;
                case EyeColour.PaleSilvery:
                    serializer.Serialize(writer, "pale, silvery");
                    return;
                case EyeColour.Red:
                    serializer.Serialize(writer, "red");
                    return;
                case EyeColour.White:
                    serializer.Serialize(writer, "white");
                    return;
                case EyeColour.Yellow:
                    serializer.Serialize(writer, "yellow");
                    return;
                case EyeColour.Yellowish:
                    serializer.Serialize(writer, "yellowish");
                    return;
            }
            throw new Exception("Cannot marshal type EyeColour");
        }

        public static readonly EyeColourConverter Singleton = new EyeColourConverter();
    }

    internal class GenderConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Gender) || t == typeof(Gender?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "female":
                    return Gender.Female;
                case "male":
                    return Gender.Male;
            }
            throw new Exception("Cannot unmarshal type Gender");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Gender)untypedValue;
            switch (value)
            {
                case Gender.Female:
                    serializer.Serialize(writer, "female");
                    return;
                case Gender.Male:
                    serializer.Serialize(writer, "male");
                    return;
            }
            throw new Exception("Cannot marshal type Gender");
        }

        public static readonly GenderConverter Singleton = new GenderConverter();
    }

    internal class HairColourConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HairColour) || t == typeof(HairColour?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return HairColour.Empty;
                case "bald":
                    return HairColour.Bald;
                case "black":
                    return HairColour.Black;
                case "blond":
                    return HairColour.Blond;
                case "blonde":
                    return HairColour.Blonde;
                case "brown":
                    return HairColour.Brown;
                case "dark":
                    return HairColour.Dark;
                case "dull":
                    return HairColour.Dull;
                case "ginger":
                    return HairColour.Ginger;
                case "grey":
                    return HairColour.Grey;
                case "red":
                    return HairColour.Red;
                case "sandy":
                    return HairColour.Sandy;
                case "silver":
                    return HairColour.Silver;
                case "tawny":
                    return HairColour.Tawny;
                case "white":
                    return HairColour.White;
            }
            throw new Exception("Cannot unmarshal type HairColour");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (HairColour)untypedValue;
            switch (value)
            {
                case HairColour.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case HairColour.Bald:
                    serializer.Serialize(writer, "bald");
                    return;
                case HairColour.Black:
                    serializer.Serialize(writer, "black");
                    return;
                case HairColour.Blond:
                    serializer.Serialize(writer, "blond");
                    return;
                case HairColour.Blonde:
                    serializer.Serialize(writer, "blonde");
                    return;
                case HairColour.Brown:
                    serializer.Serialize(writer, "brown");
                    return;
                case HairColour.Dark:
                    serializer.Serialize(writer, "dark");
                    return;
                case HairColour.Dull:
                    serializer.Serialize(writer, "dull");
                    return;
                case HairColour.Ginger:
                    serializer.Serialize(writer, "ginger");
                    return;
                case HairColour.Grey:
                    serializer.Serialize(writer, "grey");
                    return;
                case HairColour.Red:
                    serializer.Serialize(writer, "red");
                    return;
                case HairColour.Sandy:
                    serializer.Serialize(writer, "sandy");
                    return;
                case HairColour.Silver:
                    serializer.Serialize(writer, "silver");
                    return;
                case HairColour.Tawny:
                    serializer.Serialize(writer, "tawny");
                    return;
                case HairColour.White:
                    serializer.Serialize(writer, "white");
                    return;
            }
            throw new Exception("Cannot marshal type HairColour");
        }

        public static readonly HairColourConverter Singleton = new HairColourConverter();
    }

    internal class HouseConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(House) || t == typeof(House?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return House.Empty;
                case "Gryffindor":
                    return House.Gryffindor;
                case "Hufflepuff":
                    return House.Hufflepuff;
                case "Ravenclaw":
                    return House.Ravenclaw;
                case "Slytherin":
                    return House.Slytherin;
            }
            throw new Exception("Cannot unmarshal type House");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (House)untypedValue;
            switch (value)
            {
                case House.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case House.Gryffindor:
                    serializer.Serialize(writer, "Gryffindor");
                    return;
                case House.Hufflepuff:
                    serializer.Serialize(writer, "Hufflepuff");
                    return;
                case House.Ravenclaw:
                    serializer.Serialize(writer, "Ravenclaw");
                    return;
                case House.Slytherin:
                    serializer.Serialize(writer, "Slytherin");
                    return;
            }
            throw new Exception("Cannot marshal type House");
        }

        public static readonly HouseConverter Singleton = new HouseConverter();
    }

    internal class PatronusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Patronus) || t == typeof(Patronus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return Patronus.Empty;
                case "Jack Russell terrier":
                    return Patronus.JackRussellTerrier;
                case "boar":
                    return Patronus.Boar;
                case "doe":
                    return Patronus.Doe;
                case "goat":
                    return Patronus.Goat;
                case "hare":
                    return Patronus.Hare;
                case "horse":
                    return Patronus.Horse;
                case "lynx":
                    return Patronus.Lynx;
                case "otter":
                    return Patronus.Otter;
                case "persian cat":
                    return Patronus.PersianCat;
                case "stag":
                    return Patronus.Stag;
                case "swan":
                    return Patronus.Swan;
                case "tabby cat":
                    return Patronus.TabbyCat;
                case "weasel":
                    return Patronus.Weasel;
                case "wolf":
                    return Patronus.Wolf;
            }
            throw new Exception("Cannot unmarshal type Patronus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Patronus)untypedValue;
            switch (value)
            {
                case Patronus.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case Patronus.JackRussellTerrier:
                    serializer.Serialize(writer, "Jack Russell terrier");
                    return;
                case Patronus.Boar:
                    serializer.Serialize(writer, "boar");
                    return;
                case Patronus.Doe:
                    serializer.Serialize(writer, "doe");
                    return;
                case Patronus.Goat:
                    serializer.Serialize(writer, "goat");
                    return;
                case Patronus.Hare:
                    serializer.Serialize(writer, "hare");
                    return;
                case Patronus.Horse:
                    serializer.Serialize(writer, "horse");
                    return;
                case Patronus.Lynx:
                    serializer.Serialize(writer, "lynx");
                    return;
                case Patronus.Otter:
                    serializer.Serialize(writer, "otter");
                    return;
                case Patronus.PersianCat:
                    serializer.Serialize(writer, "persian cat");
                    return;
                case Patronus.Stag:
                    serializer.Serialize(writer, "stag");
                    return;
                case Patronus.Swan:
                    serializer.Serialize(writer, "swan");
                    return;
                case Patronus.TabbyCat:
                    serializer.Serialize(writer, "tabby cat");
                    return;
                case Patronus.Weasel:
                    serializer.Serialize(writer, "weasel");
                    return;
                case Patronus.Wolf:
                    serializer.Serialize(writer, "wolf");
                    return;
            }
            throw new Exception("Cannot marshal type Patronus");
        }

        public static readonly PatronusConverter Singleton = new PatronusConverter();
    }

    internal class SpeciesConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Species) || t == typeof(Species?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "acromantula":
                    return Species.Acromantula;
                case "cat":
                    return Species.Cat;
                case "centaur":
                    return Species.Centaur;
                case "dragon":
                    return Species.Dragon;
                case "ghost":
                    return Species.Ghost;
                case "giant":
                    return Species.Giant;
                case "goblin":
                    return Species.Goblin;
                case "half-giant":
                    return Species.HalfGiant;
                case "half-human":
                    return Species.HalfHuman;
                case "hippogriff":
                    return Species.Hippogriff;
                case "house-elf":
                    return Species.HouseElf;
                case "human":
                    return Species.Human;
                case "owl":
                    return Species.Owl;
                case "poltergeist":
                    return Species.Poltergeist;
                case "three-headed dog":
                    return Species.ThreeHeadedDog;
                case "vampire":
                    return Species.Vampire;
                case "werewolf":
                    return Species.Werewolf;
            }
            throw new Exception("Cannot unmarshal type Species");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Species)untypedValue;
            switch (value)
            {
                case Species.Acromantula:
                    serializer.Serialize(writer, "acromantula");
                    return;
                case Species.Cat:
                    serializer.Serialize(writer, "cat");
                    return;
                case Species.Centaur:
                    serializer.Serialize(writer, "centaur");
                    return;
                case Species.Dragon:
                    serializer.Serialize(writer, "dragon");
                    return;
                case Species.Ghost:
                    serializer.Serialize(writer, "ghost");
                    return;
                case Species.Giant:
                    serializer.Serialize(writer, "giant");
                    return;
                case Species.Goblin:
                    serializer.Serialize(writer, "goblin");
                    return;
                case Species.HalfGiant:
                    serializer.Serialize(writer, "half-giant");
                    return;
                case Species.HalfHuman:
                    serializer.Serialize(writer, "half-human");
                    return;
                case Species.Hippogriff:
                    serializer.Serialize(writer, "hippogriff");
                    return;
                case Species.HouseElf:
                    serializer.Serialize(writer, "house-elf");
                    return;
                case Species.Human:
                    serializer.Serialize(writer, "human");
                    return;
                case Species.Owl:
                    serializer.Serialize(writer, "owl");
                    return;
                case Species.Poltergeist:
                    serializer.Serialize(writer, "poltergeist");
                    return;
                case Species.ThreeHeadedDog:
                    serializer.Serialize(writer, "three-headed dog");
                    return;
                case Species.Vampire:
                    serializer.Serialize(writer, "vampire");
                    return;
                case Species.Werewolf:
                    serializer.Serialize(writer, "werewolf");
                    return;
            }
            throw new Exception("Cannot marshal type Species");
        }

        public static readonly SpeciesConverter Singleton = new SpeciesConverter();
    }

    internal class CoreConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Core) || t == typeof(Core?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return Core.Empty;
                case "dragon heartstring":
                    return Core.DragonHeartstring;
                case "phoenix feather":
                    return Core.PhoenixFeather;
                case "unicorn hair":
                    return Core.UnicornHair;
                case "unicorn tail-hair":
                    return Core.UnicornTailHair;
            }
            throw new Exception("Cannot unmarshal type Core");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Core)untypedValue;
            switch (value)
            {
                case Core.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case Core.DragonHeartstring:
                    serializer.Serialize(writer, "dragon heartstring");
                    return;
                case Core.PhoenixFeather:
                    serializer.Serialize(writer, "phoenix feather");
                    return;
                case Core.UnicornHair:
                    serializer.Serialize(writer, "unicorn hair");
                    return;
                case Core.UnicornTailHair:
                    serializer.Serialize(writer, "unicorn tail-hair");
                    return;
            }
            throw new Exception("Cannot marshal type Core");
        }

        public static readonly CoreConverter Singleton = new CoreConverter();
    }

    internal class LengthConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Length) || t == typeof(Length?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Length { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Length { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Length");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Length)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type Length");
        }

        public static readonly LengthConverter Singleton = new LengthConverter();
    }

    internal class WoodConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Wood) || t == typeof(Wood?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return Wood.Empty;
                case "ash":
                    return Wood.Ash;
                case "birch":
                    return Wood.Birch;
                case "cedar":
                    return Wood.Cedar;
                case "cherry":
                    return Wood.Cherry;
                case "chestnut":
                    return Wood.Chestnut;
                case "cypress":
                    return Wood.Cypress;
                case "elm":
                    return Wood.Elm;
                case "hawthorn":
                    return Wood.Hawthorn;
                case "holly":
                    return Wood.Holly;
                case "hornbeam":
                    return Wood.Hornbeam;
                case "larch":
                    return Wood.Larch;
                case "mahogany":
                    return Wood.Mahogany;
                case "oak":
                    return Wood.Oak;
                case "vine":
                    return Wood.Vine;
                case "walnut":
                    return Wood.Walnut;
                case "willow":
                    return Wood.Willow;
                case "yew":
                    return Wood.Yew;
            }
            throw new Exception("Cannot unmarshal type Wood");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Wood)untypedValue;
            switch (value)
            {
                case Wood.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case Wood.Ash:
                    serializer.Serialize(writer, "ash");
                    return;
                case Wood.Birch:
                    serializer.Serialize(writer, "birch");
                    return;
                case Wood.Cedar:
                    serializer.Serialize(writer, "cedar");
                    return;
                case Wood.Cherry:
                    serializer.Serialize(writer, "cherry");
                    return;
                case Wood.Chestnut:
                    serializer.Serialize(writer, "chestnut");
                    return;
                case Wood.Cypress:
                    serializer.Serialize(writer, "cypress");
                    return;
                case Wood.Elm:
                    serializer.Serialize(writer, "elm");
                    return;
                case Wood.Hawthorn:
                    serializer.Serialize(writer, "hawthorn");
                    return;
                case Wood.Holly:
                    serializer.Serialize(writer, "holly");
                    return;
                case Wood.Hornbeam:
                    serializer.Serialize(writer, "hornbeam");
                    return;
                case Wood.Larch:
                    serializer.Serialize(writer, "larch");
                    return;
                case Wood.Mahogany:
                    serializer.Serialize(writer, "mahogany");
                    return;
                case Wood.Oak:
                    serializer.Serialize(writer, "oak");
                    return;
                case Wood.Vine:
                    serializer.Serialize(writer, "vine");
                    return;
                case Wood.Walnut:
                    serializer.Serialize(writer, "walnut");
                    return;
                case Wood.Willow:
                    serializer.Serialize(writer, "willow");
                    return;
                case Wood.Yew:
                    serializer.Serialize(writer, "yew");
                    return;
            }
            throw new Exception("Cannot marshal type Wood");
        }

        public static readonly WoodConverter Singleton = new WoodConverter();
    }

    internal class YearOfBirthConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(YearOfBirth) || t == typeof(YearOfBirth?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new YearOfBirth { Integer = integerValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new YearOfBirth { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type YearOfBirth");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (YearOfBirth)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type YearOfBirth");
        }

        public static readonly YearOfBirthConverter Singleton = new YearOfBirthConverter();
    }
}
